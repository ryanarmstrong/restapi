<?php

/**
 * @file
 * REST API module file.
 */

xautoload()->registerModulePsr4(__FILE__, 'src');

use Drupal\restapi\YamlConfigDiscovery;
use Drupal\restapi\RestServices\RestService;

require_once __DIR__ . '/vendor/autoload.php';

/**
 * Implements hook_menu().
 */
function restapi_menu() {
  $config_discovery = new YamlConfigDiscovery();
  $routes = $config_discovery->parsedConfig('restapi.routes');
  cache_clear_all('routes:', 'cache_restapi_config', TRUE);

  $items = array();
  foreach ($routes as $route_name => $route) {
    cache_set("routes:$route_name", $route, 'cache_restapi_config');
    $items[$route['path']] = array(
      'page callback' => 'restapi_callback',
      'page arguments' => array($route_name),
      'delivery callback' => 'restapi_output',
      'access callback'   => TRUE,
    );
    // Set custom callback if one is defined.
    if (isset($route['callback'])) {
      $items[$route['path']]['page callback'] = $route['callback'];
    }
    // Set path wildcards if any are defined.
    if (isset($route['wildcards'])) {
      $page_arguments = array($route_name);
      foreach ($route['wildcards'] as $wildcard) {
        $page_arguments[] = $wildcard;
      }
      $items[$route['path']]['page arguments'] = $page_arguments;
    }
  }

  return $items;
}

/**
 * Basic callback for a REST Service.
 *
 * @param string $route_name
 *   The route identifier.
 * @param string $etid
 *   A passed entity ID if requesting a single entity.
 *
 * @return array
 *   A formatted response to the clients request.
 */
function restapi_callback($route_name, $etid = NULL) {
  $variables = !empty($etid) ? array('etid' => $etid) : array();
  $service = new RestService($route_name, $variables);

  return $service->generateResponse();
}

/**
 * Custom delivery callback to handle REST requests.
 */
function restapi_output($var) {
  if (isset($var)) {
    // We are returning JSON, so tell the browser.
    drupal_add_http_header('Content-Type', 'application/json');
    echo json_encode($var, JSON_UNESCAPED_SLASHES);
  }
}

function restapi_service_config($type, $id, $reset = FALSE) {
  $cache = cache_get("$type:$id", 'cache_restapi_config');
  if (!$cache || $reset) {
    $config_discovery = new YamlConfigDiscovery();
    $yaml = $config_discovery->parsedConfig('restapi.' . $type);
    $data = $yaml[$id];
    if (!empty($data)) {
      cache_set("$type:$id", $data, 'cache_restapi_config');
    }
  } else {
    $data = $cache->data;
  }
  return $data;
}

/**
 * Implements hook_flush_caches().
 */
function restapi_flush_caches() {
  return array('cache_restapi_config', 'cache_restapi_collections', 'cache_restapi_content');
}

/**
 * Implements hook_entity_insert().
 */
function restapi_entity_insert($entity, $type) {
  // Define caching strategy when an entity is inserted.
}

/**
 * Implements hook_entity_delete().
 */
function restapi_entity_delete($entity, $type) {
  // Define caching strategy when an entity is deleted.
}

/**
 * Implements hook_entity_update().
 */
function restapi_entity_update($entity, $type) {
  // Define caching strategy when an entity is updated.
}
